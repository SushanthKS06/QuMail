"""
Authentication API Routes

Handles token generation and OAuth2 flows for email providers.
"""

import logging
import secrets
from datetime import datetime, timedelta, timezone
from typing import Optional
from urllib.parse import urlencode

from fastapi import APIRouter, HTTPException, Query, status
from jose import jwt
from pydantic import BaseModel

from config import settings

logger = logging.getLogger(__name__)
router = APIRouter()

_oauth_states: dict[str, datetime] = {}


class TokenRequest(BaseModel):
    """Request for API token."""
    app_secret: str


class TokenResponse(BaseModel):
    """API token response."""
    access_token: str
    token_type: str = "bearer"
    expires_in: int


class OAuthInitResponse(BaseModel):
    """OAuth initialization response."""
    auth_url: str
    state: str


class OAuthCallbackResponse(BaseModel):
    """OAuth callback response."""
    success: bool
    email: Optional[str] = None
    error: Optional[str] = None


@router.post("/token", response_model=TokenResponse)
async def generate_token(request: TokenRequest) -> TokenResponse:
    """
    Generate API token for frontend-backend communication.
    
    The app_secret is generated by Electron at startup and shared
    via secure IPC. This prevents unauthorized access to the backend.
    """
    if not secrets.compare_digest(request.app_secret, settings.api_token):
        logger.warning("Invalid app secret received")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid app secret",
        )
    
    expires_delta = timedelta(minutes=settings.token_expire_minutes)
    expire = datetime.now(timezone.utc) + expires_delta
    
    token_data = {
        "sub": "frontend",
        "exp": expire,
        "iat": datetime.now(timezone.utc),
    }
    
    access_token = jwt.encode(
        token_data,
        settings.secret_key,
        algorithm="HS256",
    )
    
    logger.info("Generated API token, expires in %d minutes", settings.token_expire_minutes)
    
    return TokenResponse(
        access_token=access_token,
        expires_in=settings.token_expire_minutes * 60,
    )


@router.post("/oauth/gmail/init", response_model=OAuthInitResponse)
async def init_gmail_oauth() -> OAuthInitResponse:
    """
    Initialize Gmail OAuth2 flow.
    
    Returns the authorization URL that the frontend should open
    in a browser window.
    """
    if not settings.gmail_client_id:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Gmail OAuth not configured. Set GMAIL_CLIENT_ID and GMAIL_CLIENT_SECRET.",
        )
    
    state = secrets.token_urlsafe(32)
    _oauth_states[state] = datetime.now(timezone.utc)
    
    _cleanup_expired_states()
    
    params = {
        "client_id": settings.gmail_client_id,
        "redirect_uri": settings.gmail_redirect_uri,
        "response_type": "code",
        "scope": "https://mail.google.com/ openid email profile",
        "access_type": "offline",
        "prompt": "consent",
        "state": state,
    }
    
    auth_url = f"https://accounts.google.com/o/oauth2/v2/auth?{urlencode(params)}"
    
    logger.info("Initiated Gmail OAuth flow")
    return OAuthInitResponse(auth_url=auth_url, state=state)


@router.get("/oauth/gmail/callback", response_model=OAuthCallbackResponse)
async def gmail_oauth_callback(
    code: Optional[str] = Query(None),
    state: Optional[str] = Query(None),
    error: Optional[str] = Query(None),
) -> OAuthCallbackResponse:
    """
    Handle Gmail OAuth2 callback.
    
    Exchanges the authorization code for access and refresh tokens,
    then stores them securely.
    """
    if error:
        logger.warning("OAuth error: %s", error)
        return OAuthCallbackResponse(success=False, error=error)
    
    if not code or not state:
        return OAuthCallbackResponse(
            success=False,
            error="Missing code or state parameter",
        )
    
    if state not in _oauth_states:
        logger.warning("Invalid OAuth state received")
        return OAuthCallbackResponse(
            success=False,
            error="Invalid state - possible CSRF attack",
        )
    
    del _oauth_states[state]
    
    import httpx
    
    try:
        async with httpx.AsyncClient() as client:
            token_response = await client.post(
                "https://oauth2.googleapis.com/token",
                data={
                    "client_id": settings.gmail_client_id,
                    "client_secret": settings.gmail_client_secret,
                    "code": code,
                    "grant_type": "authorization_code",
                    "redirect_uri": settings.gmail_redirect_uri,
                },
            )
            
            if token_response.status_code != 200:
                logger.error("Token exchange failed: %s", token_response.text)
                return OAuthCallbackResponse(
                    success=False,
                    error="Failed to exchange authorization code",
                )
            
            tokens = token_response.json()
            
            userinfo_response = await client.get(
                "https://www.googleapis.com/oauth2/v2/userinfo",
                headers={"Authorization": f"Bearer {tokens['access_token']}"},
            )
            
            if userinfo_response.status_code == 200:
                userinfo = userinfo_response.json()
                email = userinfo.get("email")
            else:
                email = None
            
            from storage.database import store_oauth_tokens
            await store_oauth_tokens(
                email=email or "unknown",
                access_token=tokens["access_token"],
                refresh_token=tokens.get("refresh_token"),
                expires_in=tokens.get("expires_in", 3600),
            )
            
            logger.info("Gmail OAuth completed for %s", email)
            return OAuthCallbackResponse(success=True, email=email)
            
    except Exception as e:
        logger.exception("OAuth callback error: %s", e)
        return OAuthCallbackResponse(
            success=False,
            error=str(e),
        )


@router.get("/status")
async def auth_status():
    """Get current authentication status."""
    from storage.database import get_stored_accounts
    
    accounts = await get_stored_accounts()
    
    return {
        "authenticated": len(accounts) > 0,
        "accounts": [
            {
                "email": acc["email"],
                "provider": "gmail",
                "connected_at": acc["connected_at"],
            }
            for acc in accounts
        ],
    }


def _cleanup_expired_states():
    """Remove expired OAuth states (older than 10 minutes)."""
    now = datetime.now(timezone.utc)
    expired = [
        state for state, created in _oauth_states.items()
        if (now - created).total_seconds() > 600
    ]
    for state in expired:
        del _oauth_states[state]
